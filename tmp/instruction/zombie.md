# BIT 2400 – 中级编程
## 教程 5 – 继承

正如我们在课堂上讨论的，如果我们需要一个与现有类相似的类，我们可以复制现有的类并对其进行一些修改以获得新的类。注意到这样做是多么容易出错吗？这就引出了继承的概念：与其复制粘贴一个类来创建原始类的新变体，我们可以使用继承。在本教程中，你将通过扩展现有的类来创建新的类。

### Zombie28
- 创建一个`Zombie28`类，使其继承自`Zombie`类（来自28天后的快速移动僵尸）……换句话说，使`Zombie28`类成为`Zombie`的子类。你需要修改什么才能实现这一点？也许是构造函数？
- `Zombie`和`Zombie28`之间的主要区别是移动速度，但你也可以进行其他更改，如增加更多的健康值或仅使其对霰弹枪弱。对于`Zombie`和`Zombie28`类来说，有一个`printInfo`函数也是个好主意。这样就很容易指出每个Zombie的位置。
- 你的`Zombie28`类还应该具有`setDestination`、`hit`和`takeTurn`函数，以及像`Zombie`类一样的getter方法。
  - 你不应该在`Zombie28`中复制`Zombie`的属性。如果属性是受保护的，你可以访问它们。如果它们是私有的，你的`Zombie`类将需要为每个属性提供getter和setter方法。
  - `Zombie28`类的构造函数将自动首先调用`Zombie`类的构造函数，然后你将设置`Zombie28`特有的属性。
  - 析构函数（我认为你在这种情况下不需要一个）将首先清理`Zombie28`类的内存和属性，然后再调用`Zombie`类的析构函数。
  - 总的来说：你的`Zombie28`类与父类真的不应该有太大的不同。速度和可能的生命值可能有所不同，`printInfo`消息应该不同。像`takeTurn`这样的函数可以省略不写在`Zombie28`中：它已经在`Zombie`类中了。
  - 当你认为你已经成功地创建了`Zombie28`作为子类时，测试你的代码。所有常见的`Zombie`和`Zombie28`函数都应该还能正常工作。
  - 回想一下，你的`Zombie`和`Zombie28`类应该具有getter方法和函数`takeTurn`、`hit`、`setDestination`和`printInfo`。

### 纯虚函数和抽象类（Undead）
- 让我们更进一步：创建一个几乎与`Zombie`类完全相同的新类，称为`Undead`（如果你愿意，可以复制和粘贴）。
  - 在`Undead`头文件中，使其中一个函数等于0。例如：`void printInfo() = 0;`
    - 这使`Undead`类成为一个抽象类。你不能创建一个通用的`Undead`；它们是僵尸、鬼魂、吸血鬼等。
    - `=0`意味着`printInfo`是一个纯虚函数，在`Undead.cpp`中不能实现。你也不能创建一个新的`Undead`，比如“`= new Undead()`”
- 既然大部分代码都在`Undead`中，使`Zombie`类成为`Undead`的子类（这样`Zombie28`就是`Undead`的“孙子”类了）。现在`Zombie`类几乎没有什么代码，但你将需要定义`printInfo`。你的构造函数可能也应该设置`Zombie`的属性。
- 最后，你可以发挥创意，制作另一种类型的不死生物。我将制作一个飞行的吸血鬼类，因此`takeTurn`的行为会有很大不同。吸血鬼类也只会对我将要制作的木桩武器敏感。
  - 注意，继承大大减少了创建新类的难度：你只需要定义子类独有的类和属性；你不需要重新实现每个单独的函数。

### 武器类
- 让我们创建一个新的叫做`AmmoWeapon`的武器类，它的工作方式与武器类完全相同，但它有限量的弹药（通常是子弹）。你的新类应该具有与`Weapon`类相同的功能，但增加了一个名为`numRounds`的新int成员变量以及一个新的getter方法`getNumRounds`。更重要的是（对于玩家来说），如果他们尝试在没有弹药的情况下使用`AmmoWeapon`攻击，将不会发生任何事情。是的，你需要通过扩展武器类来创建这个类。测试你的新类，并随意添加其他你想要的武器类。